<job id="Comp_inventory">
<script language="VBScript" src="../libs/lib_core.vbs" ></script>
<script language="VBScript" src="../libs/lib_http.vbs" ></script>
<script language="VBScript" src="../libs/lib_displayinfo.vbs" ></script>
<script language="VBScript" src="../config.priv.vbs" ></script>
<script language="javascript" runat="server" src="../libs/lib_url.js" ></script>
<script language="VBScript">
'Скрипт сбора данных о конфигурации компа
'v0.13 + Теперь ИД компьютера сохраняется в реестре
'      * Теперь скрипт требует права админа
'v0.12 * Имя компютера теперь берется полное (а не NETBIOS)
'v0.11 * функцонинал XML парсинга и HTTP REST вынесен в lib_http, URL.encdode/decode -> lib_url
'v0.10rc2 ! Все обращения к WMI теперь идут с отключением выброса ошибок и рассчитаны на возможность сбоя запроса
'v0.10rc + Сохранение IP адреса(ов)
'v0.9.1 ! ПО считалось системной компонентой только по наличию параметра SystemComponent, независимо от значения
'v0.9  * Домен теперь не обязательное поле, что позволит отработать скрипту на недоменных машинах
'v0.8  ! Исправлено кодирование в формат JSON
'v0.7  * Операционная система теперь входит в список ПО,
'v0.6  ! значение объема видеокарты теперь текстовое,
'v0.5  ! исправлена ошибка с преобразованием пустого значения объема видеокарты в 0 на Windows XP,
'	 которая приводила к вылетанию скрипта.
'v0.4  * софт ищется еще из ветки WOW6432node
'	 софт с пометкой "системная компонента" не выводится в отчет
'	 если у софта есть метка "родительский продукт" то он в отчет выводится
'	 как родительский продукт, чтобы нам в БД не заталкивать все субкомпоненты вручную
'v0.3  + отправка данных скорректирована для соответствия JSON формату
'v0.2  * отправка новых и обновление уже имеющихся данных через API POST/PUT
'	 в принципе уже рабочий скрипт и может наполнять БД
'v0.1  + добавлена отправка данных в БД!
'v0.02 + сбор данных о железе: мать, проц, планки оперативки, диски, видео
'v0.01 * initial: сбор данных о софте из wmi product get name и веток реестра Uninstall
'	т.к. wmi отдает инфу только по продуктам установленным через MSI
'	отправки данных пока нет. только сбор


const scrName="gp_compInventory" : const scrVer="0.13"
logFile = WorkDir & scrName & ".log"

Msg "-" : Msg "Script started: "&scrName&" "&scrVer&" (core "&coreLibVer&")"
dim objWMIService
Set objWMIService = GetObject("winmgmts:{impersonationLevel=impersonate}!\\.\root\cimv2")


privelegeMe()
'checkFullAdminRights()


'поиск установленного софта в папке UNINSTALL в реестре - перебираем подпапки и ищем в них ProductName
function ListSoft(byVal HIVE, byVal path)
	dim arrSubKeys, subkey, Publisher, ProductName, ParentProduct, SystemFlag
	Msg "Searching soft in " & path & "..."
	'сначала перебираем подпапки
	objReg.EnumKey HIVE, path, arrSubKeys
	If Not IsNull(arrSubKeys) Then
		For Each subkey In arrSubKeys
			Publisher=""
			ProductName=""
			ParentProduct=""
			SystemFlag = ""
			'on error resume next
			objReg.GetStringValue HIVE, path & "\" & subkey, "Publisher", Publisher
			objReg.GetStringValue HIVE, path & "\" & subkey, "DisplayName", ProductName
			objReg.GetStringValue HIVE, path & "\" & subkey, "ParentDisplayName", ParentProduct
			objReg.GetDWORDValue HIVE, path & "\" & subkey, "SystemComponent", SystemFlag
			'on error goto 0
			if (SystemFlag = "1") then 'пропускаем системные компоненты
				Msg "System component found: "& subkey & " " & Publisher & " " & ProductName
			else 
				'если у нас есть родительский продукт, то мы его и впишем, на не интересно мелочиться разглядывая компоненты
				if (not ParentProduct = "") then ProductName = ParentProduct
				if (not ProductName = "") then
					Msg "Soft found: "& subkey & " " & Publisher & " " & ProductName
					if (Len(productList)>0) then productList=productList & ","
					productList=productList & "{""publisher"":""" & URL.addslashes(Publisher) &""", ""name"":""" & URL.addslashes(ProductName) & """}" '& vbCrLf
				end if
			end if
		Next
	End If
end function

'Ищем UNINSTALL софт в папках пользователей. Там могут быть всякие амиго и т.п.
function ListUsersSoft(byVal HIVE)
	dim arrSubKeys,subkey
	Msg "Searching USERS soft ..."
	'сначала перебираем подпапки
	objReg.EnumKey HIVE, "", arrSubKeys
	If Not IsNull(arrSubKeys) Then
		For Each subkey In arrSubKeys
			'on error resume next
			msg Subkey
			ListSoft HIVE, subkey & "\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\"
		Next
	End If
end function


'возвращает ID домена по имени или -1 если домен не найден
function getDomainID(byVal domain)
	getDomainID=getXmlResponseID(getXMLData(inventory_apihost&"/web/api/domains/"&domain))
	Msg "Got DomainID="&getDomainID&" from "&inventory_apihost&"/web/api/domains/"&domain	
end function

'возвращает ID компьютера по домену, имени или -1 если не найден
function getCompID(byVal domain, byVal name)
	getCompID=getXmlResponseID(getXMLData(inventory_apihost&"/web/api/comps/"&domain&"/"&name))
	Msg "Got CompID="&getCompID&" from "&inventory_apihost&"/web/api/comps/"&domain&"/"&name
end function

'обновлеят запись компьютера в БД, если в качестве compID передано -1, то создает новую
'возвращает ID созданной/обновленной записи
function updRecord(byVal compID, byVal domainID, byVal name, byVal OS, byVal hw, byVal sw, byVal ip)
	datetime = Year(now) & "-" & Month(now) & "-" & Day(now) & " " & Hour(now) & ":" & Minute(now)
	data=_
	"domain_id="&domainID&_
	"&name="&Url.Encode(name)&_
	"&os="&Url.Encode(OS)&_
	"&raw_hw="&Url.Encode(hw)&_
	"&raw_soft="&Url.Encode(sw)&_
	"&raw_version="&Url.Encode(scrVer)&_
	"&ip="&Url.Encode(ip)&_
	"&updated_at="&Url.Encode(datetime)

	'сохраняем данные в отдельный файлик. На случай если с сервером связаться не удастся
	writeFile WorkDir & scrName & ".dat", data

	if (compID>-1) then
		res=putXmlData(inventory_apihost & "/web/api/comps/"&compID,data)
	else
		res=postXmlData(inventory_apihost & "/web/api/comps",data)
	end if

	id = getXmlResponseID(res)

	if (id > -1) then
		Msg "Got actual compID " & id & "; Database updated"
	else
		Msg "ERR: failed send data to database: " & vbCrLf &_
			"data=" & data & vbCrLf &_
			"response=" & res
	end if

	updRecord = id	
end function

' получить IP-адрес
function getIPv4addrs()
	dim Text 
	Text = ""
	on error resume next
	dim IPConfigSet: Set IPConfigSet = objWMIService.ExecQuery("Select IPAddress from Win32_NetworkAdapterConfiguration where ipenabled = true")
	dim IPConfig 
	for each IPConfig in IPConfigSet
	    	if Not IsNull(IPConfig.IPAddress) then 
	        	for i=LBound(IPConfig.IPAddress) to UBound(IPConfig.IPAddress)
	            		If InStr(IPConfig.IPAddress(i),":") = 0 Then Text = Text & IPConfig.IPAddress(i)& VbCrLf
	        	next
		end if
	next
	on error goto 0
	getIPv4addrs=Text
end function

'заполняем отпечаток софта
productList=""
ListSoft HKEY_LOCAL_MACHINE, "SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\"
ListSoft HKEY_LOCAL_MACHINE, "SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\"
ListUsersSoft HKEY_USERS

msg "Searching hw..."
on error resume next

'заполняем отпечаток железа
hwList=""
msg "Searching MB..."
Set colItems = objWMIService.ExecQuery( "Select * from Win32_BaseBoard", , 48 )
For Each objItem in colItems
	comma=""
	if (Len(hwList)>0) then comma= ","
	hwList = hwList & comma & "{""motherboard"":{"_
		& """manufacturer"":""" & TrimWithTabs( URL.addslashes(objItem.Manufacturer )) & """, " _
		& """product"":""" &TrimWithTabs( URL.addslashes(objItem.Product ))  & """, " _
		& """serial"":""" &TrimWithTabs( URL.addslashes(objItem.SerialNumber ))  & """" _
	& "}}"
	'hard(UBound(hard))="{""publisher"":""" & Publisher &""", ""name"":""" & ProductName & """}"
Next

msg "Searching CPU..."

Set colItems = objWMIService.ExecQuery( "Select * from Win32_Processor", , 48 )
For Each objItem in colItems
	comma=""
	if (Len(hwList)>0) then comma= ","
	hwList = hwList & comma & "{""processor"":{" _
		& """model"":""" & TrimWithTabs( URL.addslashes(objItem.Name)) & """, " _
		& """cores"":"""&objItem.numberOfCores&"""" _
	& "}}"
Next

msg "Searching MEM Banks..."

Set colItems = objWMIService.ExecQuery("Select * from Win32_PhysicalMemory")
For Each objItem in colItems
	comma=""
	if (Len(hwList)>0) then comma= ","
	hwList = hwList & comma & "{""memorybank"":{"_
		& """manufacturer"":""" & URL.addslashes(objItem.Manufacturer) & """, "_
		& """capacity"":""" & round(objItem.Capacity / 1048576) & """" _
	& "}}"
Next

msg "Searching Drives..."

Set colItems = objWMIService.ExecQuery( "Select * from Win32_DiskDrive", , 48 )
For Each objItem in colItems
	driveSize=objItem.Size
	if (isnull(driveSize)) then driveSize=0

	comma=""
	if (Len(hwList)>0) then comma= ","
	hwList = hwList & comma & "{""harddisk"":{" _
		& """model"":""" & URL.addslashes(objItem.Model) & """," _
		& """size"":""" & Int(round(CDbl(driveSize) /1000/1000/1000)) & """" _
	& "}}"
Next

msg "Searching GPU..."

' Query video adapter properties
Set colItems = objWMIService.ExecQuery( "Select * from Win32_VideoController", , 48 )
For Each objItem in colItems
	comma=""
	if (Len(hwList)>0) then comma= ","
	hwList = hwList & comma & "{""videocard"":{" _
		& """name"":""" & URL.addslashes(objItem.Name) & """," _
		& """ram"":""" & Int( ( abs(objItem.AdapterRAM )) / 1024 /1024 ) & """" _
	& "}}"
Next

' Query video adapter properties
'Set colItems = objWMIService.ExecQuery( "Select * from Win32_DesktopMonitor", , 48 )
'For Each objItem in colItems
'	if (Len(hwList)>0) then hwList=hwList & ","
'	hwList = hwList & "{""display"":{" _
'		& """manufacturer"":""" & objItem.MonitorManufacturer & """," _
'		& """model"":""" & objItem.Caption & """" _
'	& "}}"
'Next

' Get Windows serial
'Set colItems = objWMIService.ExecQuery( "Select * from SoftwareLicensingService", , 48 )
'For Each objItem in colItems
'	productList=productList & ",{""publisher"":""Microsoft"", ""name"":""Windows " & objItem.OA3xOriginalProductKeyDescription & """, ""key"":""" & objItem.OA3xOriginalProductKey & """}" '& vbCrLf
'Next



msg "Searching Display ..."

monList=GetMonitorInfo
if (Len(monList)>0 ) then
	if (Len(hwList)>0) then hwList=hwList & ","
	hwList=hwList & monList
end if


msg "Searching OS Version ..."
Set colItems = objWMIService.ExecQuery( "Select * from Win32_OperatingSystem", , 48 )
For Each objItem in colItems
	strOS = objItem.Version&" "&objItem.Caption
	if (Len(productList)>0) then productList=productList & ","
	productList=productList & "{""publisher"":""Microsoft"", ""name"":""" & URL.addslashes(objItem.Caption) & """}" '& vbCrLf
Next


msg "Searching IPs ..."
IPv4addrs=getIPv4addrs()

dim domainID, compID

msg "Searching Domain name..."
Set colItems = objWMIService.ExecQuery( "Select * from Win32_ComputerSystem", , 48 )
For Each objItem in colItems
	strComputerDomain = split(objItem.Domain,".")(0)
Next

domainID=getDomainID(strComputerDomain)
if (domainID = -1) then
	Halt "Domain "&strComputerDomain&" not found in inventory database. Please add it manually"
	'domainID=""
	'wscript.quit
end if

msg "Searching OS..."

const regStorage="HKEY_LOCAL_MACHINE\SOFTWARE\Reviakin\Inventory\"
compID=regRead(regStorage & "compID")

if (compID = false) then
	msg "INFO: no saved CompID found. Searching in database..."
	compID=getCompID(strComputerDomain, ComputerName)	
else
	msg "INFO: got CompID=" & CompID
end if


id = updRecord(compID, domainID, ComputerName, strOS, hwList, productList, IPv4addrs)

if (id > -1) then
	regWrite regStorage & "compID", "REG_SZ", id
end if

</script>
</job>