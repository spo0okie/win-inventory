<job id="Comp_inventory">
<script language="VBScript" src="../libs/lib_core2.vbs" ></script>
<script language="VBScript" src="../libs/lib_uac2.vbs" ></script>
<script language="VBScript" src="../libs/lib_reg2.vbs" ></script>
<script language="VBScript" src="../libs/lib_wmi2.vbs" ></script>
<script language="VBScript" src="../libs/lib_fileio.vbs" ></script>
<script language="VBScript" src="../libs/lib_http.vbs" ></script>
<script language="VBScript" src="../libs/lib_inventory.vbs" ></script>
<script language="VBScript" src="../libs/lib_displayinfo.vbs" ></script>
<script language="VBScript" src="../config.priv.vbs" ></script>
<script language="javascript" runat="server" src="../libs/lib_url.js" ></script>
<script language="VBScript">
option explicit
DEBUGMODE = 0

'Скрипт сбора данных о конфигурации компа
'v2.3  ! исключены виртуальные сетевые адаптеры из списка сетевых карт
'v2.2  * добавлен сбор информации о серийных номерах всех компонентов
'v2.1  ! исправлен баг с игнорированием кэша ПО
'v2.0  * переход на использование lib_core2 (v3.0)
'      + Кэширование пользовательского софта для последющего его учета в списке ПО в случае когда его реестр не загружен (пользователь не входил в ПК)
'        это сключает ситуации с "морганием" пользовательского ПО в общем списке
'      * уменьшен общий объем списка ПО, т.к. передаются только уникальные записи (ввиду того, что мы переименовываем компоненты в своего родителя)
'v0.18 ! Microsoft Virtual Disk также исключен из списка оборудования
'v0.17 ! видеокарта Microsoft Remote Display Adapter исключается из оборудования, т.к. она то есть то нет, что забивает журналы изменений
'v0.16 * работа с новым API с обязательной авторизайие, слепым PUSH данных, без чтения вообще с минимальным набором прав
'v0.15 * включен option explicit, все функции работы с инвентори вынесены в библиотеку (так также option explicit)
'v0.14 + Теперь собирается и MAC (Требуется поддержка со стороны БД)
'v0.13 + Теперь ИД компьютера сохраняется в реестре
'      * Теперь скрипт требует права админа
'v0.12 * Имя компютера теперь берется полное (а не NETBIOS)
'v0.11 * функцонинал XML парсинга и HTTP REST вынесен в lib_http, URL.encdode/decode -> lib_url
'v0.10rc2 ! Все обращения к WMI теперь идут с отключением выброса ошибок и рассчитаны на возможность сбоя запроса
'v0.10rc + Сохранение IP адреса(ов)
'v0.9.1 ! ПО считалось системной компонентой только по наличию параметра SystemComponent, независимо от значения
'v0.9  * Домен теперь не обязательное поле, что позволит отработать скрипту на недоменных машинах
'v0.8  ! Исправлено кодирование в формат JSON
'v0.7  * Операционная система теперь входит в список ПО,
'v0.6  ! значение объема видеокарты теперь текстовое,
'v0.5  ! исправлена ошибка с преобразованием пустого значения объема видеокарты в 0 на Windows XP,
'	 которая приводила к вылетанию скрипта.
'v0.4  * софт ищется еще из ветки WOW6432node
'	 софт с пометкой "системная компонента" не выводится в отчет
'	 если у софта есть метка "родительский продукт" то он в отчет выводится
'	 как родительский продукт, чтобы нам в БД не заталкивать все субкомпоненты вручную
'v0.3  + отправка данных скорректирована для соответствия JSON формату
'v0.2  * отправка новых и обновление уже имеющихся данных через API POST/PUT
'	 в принципе уже рабочий скрипт и может наполнять БД
'v0.1  + добавлена отправка данных в БД!
'v0.02 + сбор данных о железе: мать, проц, планки оперативки, диски, видео
'v0.01 * initial: сбор данных о софте из wmi product get name и веток реестра Uninstall
'	т.к. wmi отдает инфу только по продуктам установленным через MSI
'	отправки данных пока нет. только сбор

forceCscript()

const scrName="gp_compInventory" : const scrVer="win 2.3"
dim logFile : logFile = WorkDir & scrName & ".log"

Msg "-" : Msg "Script started: "&scrName&" "&scrVer&" (core "&coreLibVer&")"

privelegeMe()
checkFullAdminRights()

dim objWMIService
Set objWMIService = GetObject("winmgmts:{impersonationLevel=impersonate}!\\.\root\cimv2")

'виртуальные диски для игнорирования в списке оборудования (майкрософтовские user profile disks в RDP моргают)
dim virtualDrives : virtualDrives = array("Microsoft Virtual Disk","Виртуальный диск (Майкрософт)")
'виртуальные видеоадаптеры (RDP и т.п.)
dim virtualVideo : virtualVideo = array("Microsoft Remote Display Adapter",	"Microsoft RemoteFX")
'виртуальные сетевые адаптеры (docker, vbox, tun/tap, WSL и т.п.)
dim virtualNetDrivers : virtualNetDrivers = array( _
								"Microsoft Virtual WiFi Miniport Adapter", _
								"Microsoft Wi-Fi Direct Virtual Adapter", _
								"VirtualBox Host-Only Ethernet Adapter", _
								"VirtualBox Bridged Networking Driver", _
								"TAP-Windows Adapter V9", _
								"DockerNAT" _
							)
dim virtualNetNames : virtualNetNames = array(	"vEthernet", _
								"Loopback", _
								"Virtual WiFi", _
								"vEthernet (WSL)", _
								"Wi-Fi Direct", _
								"VirtualBox", _
								"TAP-Windows", _
								"Docker" _
							)

checkDir inventory_local_cache

dim colItems,objItem

'проверяет содержит ли строка name хотя бы одну из подстрок в массиве stringArray
'для проверки оборудования на шаблоны имен (виртуальные видеоадаптеры, диски, сетевые адаптеры и т.п.)
Function ContainsSubstring(ByVal name, ByVal stringArray)
    Dim i, result
    result = False

    If IsArray(stringArray) Then
        For i = LBound(stringArray) To UBound(stringArray)
            If InStr(1, name, stringArray(i), vbTextCompare) > 0 Then
                result = True
                Exit For
            End If
        Next
    End If

    ContainsSubstring = result
End Function

'поиск установленного софта в папке UNINSTALL в реестре - перебираем подпапки и ищем в них ProductName
function ListSoft(byVal Path)
	ListSoft=""
	dim arrSubKeys, subkey, Publisher, ProductName, ParentProduct, SystemFlag
	
	Msg "Searching soft in " & Path & "..."
	'сначала перебираем подпапки
	arrSubKeys = RegEnumKeys (Path)
	If Not IsNull(arrSubKeys) Then
		For Each subkey In arrSubKeys

			Publisher=	RegRead (Path & "\" & subkey & "\Publisher") 
			ProductName=	RegRead (Path & "\" & subkey & "\DisplayName")
			ParentProduct=	RegRead (Path & "\" & subkey & "\ParentDisplayName")
			SystemFlag=	RegRead (Path & "\" & subkey & "\SystemComponent")

			if (SystemFlag = "1") then 'пропускаем системные компоненты
				Msg "System component skip: "& subkey & " " & Publisher & " " & ProductName
			else 
				'если у нас есть родительский продукт, то мы его и впишем, нам не интересно мелочиться разглядывая компоненты
				if not (ParentProduct = "" or ParentProduct = false) then ProductName = ParentProduct
				if not (ProductName = "" or ProductName = false) then
					Msg "Soft found: "& subkey & " " & Publisher & " " & ProductName
					stringCommaAdd ListSoft, vbCrLf, _ 
						"{""publisher"":""" & URL.addslashes(Publisher) & """, ""name"":""" & URL.addslashes(ProductName) & """}"
				end if
			end if
		Next
	End If
end function

'Ищем UNINSTALL софт в папках пользователей. Там могут быть всякие амиго и т.п.
function ListUsersSoft()
	ListUsersSoft=""
	dim arrProfiles, profile, profileSoft, cacheFile
	Msg "Searching USERS soft ..."
	'сначала перебираем профили
	arrProfiles = RegEnumKeys("HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList")
	If Not IsNull(arrProfiles) Then
		For Each profile In arrProfiles
			if right(profile,4) = ".bak" then
				msg profile & " - SKIP"
			else
				cacheFile = inventory_local_cache & "\" & profile
				if regPathExists ("HKEY_USERS\" & profile) then
					msg profile & " - LOADED"
					profileSoft=ListSoft ("HKEY_USERS\" & profile & "\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\")
					WriteFile cacheFile, profileSoft
				elseif objFSO.FileExists(cacheFile) then
					msg profile & " - CACHED"
					profileSoft = getFile(cacheFile)
					if Len(profileSoft)>0 then
						msg "User soft loaded:"& vbCrLf & profileSoft
					else
						msg "User soft list empty"
					end if
				else
					msg profile & " - MISSING"
					profileSoft = ""
				end if		
				stringCommaAdd ListUsersSoft,vbCrLf,profileSoft
			end if
		Next
	End If
end function


Function IsVirtualAdapter(adapterName, connectionID)
    IsVirtualAdapter = False

    If ContainsSubstring(adapterName, virtualNetDrivers) Then
        IsVirtualAdapter = True
        Exit Function
    End If

    If ContainsSubstring(connectionID, virtualNetNames) Then
        IsVirtualAdapter = True
        Exit Function
    End If
End Function

' получить IP-адреса и MAC-адреса всех физических сетевых адаптеров
Sub CollectNetInfo()
    Dim IPConfigSet, IPConfig
    Dim AdapterSet, Adapter
    Dim i

    On Error Resume Next
    Set IPConfigSet = objWMIService.ExecQuery( "Select IPAddress, MACAddress, Index from Win32_NetworkAdapterConfiguration where IPEnabled = True")

    For Each IPConfig In IPConfigSet
        
        Set AdapterSet = objWMIService.ExecQuery( "Select Name, NetConnectionID from Win32_NetworkAdapter where Index = " & IPConfig.Index)

        For Each Adapter In AdapterSet

            If Not IsVirtualAdapter(Adapter.Name, Adapter.NetConnectionID) Then
                
                ' IPv4
                If Not IsNull(IPConfig.IPAddress) Then
                    For i = LBound(IPConfig.IPAddress) To UBound(IPConfig.IPAddress)
                        If InStr(IPConfig.IPAddress(i), ":") = 0 Then
                            IPv4addrs = IPv4addrs & IPConfig.IPAddress(i) & vbCrLf
                        End If
                    Next
                End If

                ' MAC
                If Not IsNull(IPConfig.MACAddress) Then
                    MACaddrs = MACaddrs & IPConfig.MACAddress & vbCrLf
                End If

            End If

        Next
    Next
    On Error GoTo 0
End Sub

'заполняем отпечаток софта
dim productList : productList=""
stringCommaAdd productList, vbCrLf, ListSoft("HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\")
stringCommaAdd productList, vbCrLf, ListSoft("HKLM\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\")
stringCommaAdd productList, vbCrLf, ListUsersSoft()

productList=arrayImplode(arrayUniqueStrings(stringExplode(productList,vbCrLf)),",")
wscript.echo productList

msg "Searching hw..."
on error resume next

'заполняем отпечаток железа
dim hwList: hwList=""

msg "Searching MB..."
For Each objItem in getWmiQueryArrayCrit( "Select * from Win32_BaseBoard")
	stringCommaAdd hwList, ",", "{""motherboard"":{"_
		& """manufacturer"":""" & TrimWithTabs( URL.addslashes(objItem.Manufacturer )) & """, " _
		& """product"":""" & TrimWithTabs( URL.addslashes(objItem.Product )) & """, " _
		& """serial"":""" & TrimWithTabs( URL.addslashes(objItem.SerialNumber )) & """" _
	& "}}"
Next

msg "Searching CPU..."
For Each objItem in getWmiQueryArrayCrit( "Select * from Win32_Processor")
	stringCommaAdd hwList, ",", "{""processor"":{" _
		& """model"":""" & TrimWithTabs( URL.addslashes(objItem.Name)) & """, " _
		& """cores"":""" & objItem.numberOfCores & """, " _
		& """serial"":""" & TrimWithTabs( URL.addslashes(objItem.SerialNumber )) & """" _
	& "}}"
Next

msg "Searching MEM Banks..."
For Each objItem in getWmiQueryArrayCrit("Select * from Win32_PhysicalMemory")
	stringCommaAdd hwList, ",", "{""memorybank"":{"_
		& """manufacturer"":""" & URL.addslashes(objItem.Manufacturer) & """, "_
		& """capacity"":""" & round(objItem.Capacity / 1048576) & """, " _
		& """serial"":""" & TrimWithTabs( URL.addslashes(objItem.SerialNumber )) & """" _
	& "}}"
Next

msg "Searching Drives..."
For Each objItem in getWmiQueryArrayCrit("Select * from Win32_DiskDrive")
	dim driveSize : driveSize=objItem.Size
	if (isnull(driveSize)) then driveSize=0

	if not ContainsSubstring(objItem.Model,virtualDrives) then
		stringCommaAdd hwList, ",", "{""harddisk"":{" _
			& """model"":""" & URL.addslashes(objItem.Model) & """," _
			& """size"":""" & Int(round(CDbl(driveSize) /1000/1000/1000)) & """," _
			& """serial"":""" &TrimWithTabs( URL.addslashes(objItem.SerialNumber ))  & """" _
		& "}}"
	end if
Next

msg "Searching GPU..."
For Each objItem in getWmiQueryArrayCrit( "Select * from Win32_VideoController")
	dim cardOk: cardOk=true
	'пропускаем не настоящую видеокарту ибо она может моргать то есть то нет, чем забивать историю изменения ОС
	if not ContainsSubstring(objItem.name,virtualVideo) then
		stringCommaAdd hwList, ",", "{""videocard"":{" _
			& """name"":""" & URL.addslashes(objItem.Name) & """," _
			& """ram"":""" & Int( ( abs(objItem.AdapterRAM )) / 1024 /1024 ) & """, " _
			& """serial"":""" & TrimWithTabs( URL.addslashes(objItem.SerialNumber )) & """" _
		& "}}"
	end if
Next

msg "Searching Display ..."

dim monList : monList=GetMonitorInfo
if (Len(monList)>0 ) then
	stringCommaAdd hwList, ",", monList
end if

on error goto 0

msg "Searching OS Version ..."
dim strOS
For Each objItem in getWmiQueryArrayCrit( "Select * from Win32_OperatingSystem")
	strOS = objItem.Version&" "&objItem.Caption
	stringCommaAdd hwList, ",", "{""publisher"":""Microsoft"", ""name"":""" & URL.addslashes(objItem.Caption) & """}"
Next

msg "Searching IPs ..."
dim IPv4addrs 
dim MACaddrs
CollectNetInfo

dim domainID, compID

msg "Searching Domain name..."
dim strComputerDomain
For Each objItem in getWmiQueryArrayCrit( "Select * from Win32_ComputerSystem")
	strComputerDomain = objItem.Domain
Next

dim id : id = invPushComp(ComputerName & "." & strComputerDomain, strOS, hwList, productList, IPv4addrs, MACaddrs)

if (id > -1) then
	regWrite inventoryCompIDRegStorage, "REG_SZ", id
end if

</script>

</job>