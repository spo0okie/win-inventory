<job id="Comp_inventory">
<script language="VBScript" src="../libs/lib_core.vbs" ></script>
<script language="VBScript" src="../libs/lib_displayinfo.vbs" ></script>
<script language="VBScript" src="../config.priv.vbs" ></script>
<script language="javascript" runat="server">
URL = {
    encode : function(s){return encodeURIComponent(s).replace(/'/g,"%27").replace(/"/g,"%22")},
    decode : function(s){return decodeURIComponent(s.replace(/\+/g,  " "))},
    addslashes: function (s) {
    if (!s) return '';
    return s.replace(/\\/g, '\\\\').
        replace(/\u0008/g, '\\b').
        replace(/\t/g, '\\t').
        replace(/\n/g, '\\n').
        replace(/\f/g, '\\f').
        replace(/\r/g, '\\r').
        //replace(/'/g, '\\\'').
        replace(/"/g, '\\"');
     }

}
</script>
<script language="VBScript">
'Скрипт сбора данных о конфигурации компа
'v0.10rc + Сохранение IP адреса(ов)
'v0.9.1 ! ПО считалось системной компонентой только по наличию параметра SystemComponent, независимо от значения
'v0.9  * Домен теперь не обязательное поле, что позволит отработать скрипту на недоменных машинах
'v0.8  ! Исправлено кодирование в формат JSON
'v0.7  * Операционная система теперь входит в список ПО,
'v0.6  ! значение объема видеокарты теперь текстовое,
'v0.5  ! исправлена ошибка с преобразованием пустого значения объема видеокарты в 0 на Windows XP,
'	 которая приводила к вылетанию скрипта.
'v0.4  * софт ищется еще из ветки WOW6432node
'	 софт с пометкой "системная компонента" не выводится в отчет
'	 если у софта есть метка "родительский продукт" то он в отчет выводится
'	 как родительский продукт, чтобы нам в БД не заталкивать все субкомпоненты вручную
'v0.3  + отправка данных скорректирована для соответствия JSON формату
'v0.2  * отправка новых и обновление уже имеющихся данных через API POST/PUT
'	 в принципе уже рабочий скрипт и может наполнять БД
'v0.1  + добавлена отправка данных в БД!
'v0.02 + сбор данных о железе: мать, проц, планки оперативки, диски, видео
'v0.01 * initial: сбор данных о софте из wmi product get name и веток реестра Uninstall
'	т.к. wmi отдает инфу только по продуктам установленным через MSI
'	отправки данных пока нет. только сбор


const scrName="gp_compInventory" : const scrVer="0.10rc"
Dim LogFile : Set logFile = objFSO.OpenTextFile(WorkDir & scrName & ".log", 8, True)
Msg "-" : Msg "Script started: "&scrName&" "&scrVer
dim objWMIService
Set objWMIService = GetObject("winmgmts:{impersonationLevel=impersonate}!\\.\root\cimv2")


'поиск установленного софта в папке UNINSTALL в реестре - перебираем подпапки и ищем в них ProductName
function ListSoft(byVal HIVE, byVal path)
	dim arrSubKeys, subkey, Publisher, ProductName, ParentProduct, SystemFlag
	Msg "Searching soft in " & path & "..."
	'сначала перебираем подпапки
	objReg.EnumKey HIVE, path, arrSubKeys
	If Not IsNull(arrSubKeys) Then
		For Each subkey In arrSubKeys
			Publisher=""
			ProductName=""
			ParentProduct=""
			SystemFlag = ""
			'on error resume next
			objReg.GetStringValue HIVE, path & "\" & subkey, "Publisher", Publisher
			objReg.GetStringValue HIVE, path & "\" & subkey, "DisplayName", ProductName
			objReg.GetStringValue HIVE, path & "\" & subkey, "ParentDisplayName", ParentProduct
			objReg.GetDWORDValue HIVE, path & "\" & subkey, "SystemComponent", SystemFlag
			'on error goto 0
			if (SystemFlag = "1") then 'пропускаем системные компоненты
				Msg "System component found: "& subkey & " " & Publisher & " " & ProductName
			else 
				'если у нас есть родительский продукт, то мы его и впишем, на не интересно мелочиться разглядывая компоненты
				if (not ParentProduct = "") then ProductName = ParentProduct
				if (not ProductName = "") then
					Msg "Soft found: "& subkey & " " & Publisher & " " & ProductName
					if (Len(productList)>0) then productList=productList & ","
					productList=productList & "{""publisher"":""" & URL.addslashes(Publisher) &""", ""name"":""" & URL.addslashes(ProductName) & """}" '& vbCrLf
				end if
			end if
		Next
	End If
end function

'Ищем UNINSTALL софт в папках пользователей. Там могут быть всякие амиго и т.п.
function ListUsersSoft(byVal HIVE)
	dim arrSubKeys,subkey
	Msg "Searching USERS soft ..."
	'сначала перебираем подпапки
	objReg.EnumKey HIVE, "", arrSubKeys
	If Not IsNull(arrSubKeys) Then
		For Each subkey In arrSubKeys
			ListSoft HIVE, subkey & "\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\"
		Next
	End If
end function

'отправить данные POST запросом //нужно для новых записей в БД
function postData(byVal host, byVal req, byVal data)
	Dim  xmlHTTP
	Set xmlHTTP = CreateObject("Microsoft.XMLHTTP")
   
	msg "HTTP POST-ing HTTP://"&host&"/"&req	'&"["&data&"]"
	xmlHTTP.Open "POST", "HTTP://"&host&"/"&req, false
   	xmlHTTP.setRequestHeader "Content-Type", "application/x-www-form-urlencoded"
    	xmlHTTP.setRequestHeader "Content-Length", CStr(Len(data))
	xmlHTTP.SetRequestHeader "accept","application/xml"
    	xmlHTTP.Send CStr(data)
	Do While xmlHTTP.readystate <> 4: WScript.Sleep 200: Loop
    	postData = xmlHTTP.responseText 
End Function

'отправить данные PUT запросом //нужно для обновления записей в БД
function putData(byVal host, byVal req, byVal data)
	Dim  xmlHTTP
	Set xmlHTTP = CreateObject("Microsoft.XMLHTTP")
    
	msg "HTTP PUT-ing HTTP://"&host&"/"&req	'&"["&data&"]"
	xmlHTTP.Open "PUT", "HTTP://"&host&"/"&req, false
   	xmlHTTP.setRequestHeader "Content-Type", "application/x-www-form-urlencoded"
    	xmlHTTP.setRequestHeader "Content-Length", CStr(Len(data))
	xmlHTTP.SetRequestHeader "accept","application/xml"
   	xmlHTTP.Send CStr(data)
	Do While xmlHTTP.readystate <> 4: WScript.Sleep 200: Loop
    	putData = xmlHTTP.responseText 
End Function

'получить данные GET запросом
function getXMLData(byVal url)
	Dim xmlHTTP
	Set xmlHTTP = CreateObject("Microsoft.XMLHTTP")
	Msg "HTTP GET-ting data from "&url&"..."
	xmlHTTP.Open "GET", url , false
	xmlHTTP.SetRequestHeader "accept","application/xml"
	xmlHTTP.Send
	if (xmlHTTP.status=200) then
		getXMLData = xmlHTTP.responseText
		Msg "HTTP GET-ting OK"
	else
		Msg "HTTP GET-ting error: status "&xmlHTTP.status
		getXMLData = "error"
	end if
End function

'получает значение поля ID из XML ответа сервера или -1 если ID не найден
function getResponseID(byVal Response)
	getResponseID=-1

	dim doc: Set doc = CreateObject("MSXML2.DOMDocument") 
	doc.loadXML(Response)
	Set nodes = doc.getElementsByTagName("id")
	for each node in nodes
		getResponseID=node.text
	next
end function

'возвращает ID домена по имени или -1 если домен не найден
function getDomainID(byVal domain)
	getDomainID=getResponseID(getXMLData("http://"&inventory_apihost&"/web/api/domains/"&domain))
	Msg "Got DomainID="&getDomainID&" from http://"&inventory_apihost&"/web/api/domains/"&domain	
end function

'возвращает ID компьютера по домену, имени или -1 если не найден
function getCompID(byVal domain, byVal name)
	getCompID=getResponseID(getXMLData("http://"&inventory_apihost&"/web/api/comps/"&domain&"/"&name))
	Msg "Got CompID="&getCompID&" from http://"&inventory_apihost&"/web/api/comps/"&domain&"/"&name
end function

'обновлеят запись компьютера в БД, если в качестве compID передано -1, то создает новую
'возвращает ID созданной/обновленной записи
function updRecord(byVal compID, byVal domainID, byVal name, byVal OS, byVal hw, byVal sw, byVal ip)
	datetime = Year(now) & "-" & Month(now) & "-" & Day(now) & " " & Hour(now) & ":" & Minute(now)
	data=_
	"domain_id="&domainID&_
	"&name="&Url.Encode(name)&_
	"&os="&Url.Encode(OS)&_
	"&raw_hw="&Url.Encode(hw)&_
	"&raw_soft="&Url.Encode(sw)&_
	"&raw_version="&Url.Encode(scrVer)&_
	"&ip="&Url.Encode(ip)&_
	"&updated_at="&Url.Encode(datetime)

	'сохраняем данные в отдельный файлик. На случай если с сервером связаться не удастся
	Dim dataFileObj
	Set dataFileObj = objFSO.OpenTextFile(WorkDir & scrName & ".dat", 2, True)
	dataFileObj.WriteLine(data)
	dataFileObj.close

	if (compID>-1) then
		res=putData(inventory_apihost,"web/api/comps/"&compID,data)
	else
		res=postData(inventory_apihost,"web/api/comps",data)
	end if
	if (getResponseID(res) > -1) then
		updRecord="ok"
	else
		updRecord= vbCrLf & "data=" & data & vbCrLf & "response=" & res
	end if
	
end function

' получить IP-адрес
function getIPv4addrs()
	dim Text 
	Text = ""
	dim IPConfigSet: Set IPConfigSet = objWMIService.ExecQuery("Select IPAddress from Win32_NetworkAdapterConfiguration where ipenabled = true")
	dim IPConfig 
	for each IPConfig in IPConfigSet
	    	if Not IsNull(IPConfig.IPAddress) then 
	        	for i=LBound(IPConfig.IPAddress) to UBound(IPConfig.IPAddress)
	            		If InStr(IPConfig.IPAddress(i),":") = 0 Then Text = Text & IPConfig.IPAddress(i)& VbCrLf
	        	next
		end if
	next
	getIPv4addrs=Text
end function

'заполняем отпечаток софта
productList=""
ListSoft HKEY_LOCAL_MACHINE, "SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\"
ListSoft HKEY_LOCAL_MACHINE, "SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\"
ListUsersSoft HKEY_USERS

msg "Searching hw..."
'заполняем отпечаток железа
hwList=""

Set colItems = objWMIService.ExecQuery( "Select * from Win32_BaseBoard", , 48 )
For Each objItem in colItems
	if (Len(hwList)>0) then hwList=hwList & ","
	hwList = hwList & "{""motherboard"":{"_
		& """manufacturer"":""" & TrimWithTabs( URL.addslashes(objItem.Manufacturer )) & """, " _
		& """product"":""" &TrimWithTabs( URL.addslashes(objItem.Product ))  & """, " _
		& """serial"":""" &TrimWithTabs( URL.addslashes(objItem.SerialNumber ))  & """" _
	& "}}"
	'hard(UBound(hard))="{""publisher"":""" & Publisher &""", ""name"":""" & ProductName & """}"
Next

Set colItems = objWMIService.ExecQuery( "Select * from Win32_Processor", , 48 )
For Each objItem in colItems
	if (Len(hwList)>0) then hwList=hwList & ","
	hwList = hwList & "{""processor"":""" & TrimWithTabs( URL.addslashes(objItem.Name)) & """}"
Next

Set colItems = objWMIService.ExecQuery("Select * from Win32_PhysicalMemory")
For Each objItem in colItems
	if (Len(hwList)>0) then hwList=hwList & ","
	hwList = hwList &  "{""memorybank"":{"_
		& """manufacturer"":""" & URL.addslashes(objItem.Manufacturer) & """, "_
		& """capacity"":""" & round(objItem.Capacity / 1048576) & """" _
	& "}}"
Next
Set colItems = objWMIService.ExecQuery( "Select * from Win32_DiskDrive", , 48 )
For Each objItem in colItems
	if (Len(hwList)>0) then hwList=hwList & ","
	driveSize=objItem.Size
	if (isnull(driveSize)) then driveSize=0
	hwList = hwList & "{""harddisk"":{" _
		& """model"":""" & URL.addslashes(objItem.Model) & """," _
		& """size"":""" & Int(round(CDbl(driveSize) /1000/1000/1000)) & """" _
	& "}}"
Next

' Query video adapter properties
Set colItems = objWMIService.ExecQuery( "Select * from Win32_VideoController", , 48 )
For Each objItem in colItems
	if (Len(hwList)>0) then hwList=hwList & ","
	hwList = hwList & "{""videocard"":{" _
		& """name"":""" & URL.addslashes(objItem.Name) & """," _
		& """ram"":""" & Int( ( abs(objItem.AdapterRAM )) / 1024 /1024 ) & """" _
	& "}}"
Next

' Query video adapter properties
'Set colItems = objWMIService.ExecQuery( "Select * from Win32_DesktopMonitor", , 48 )
'For Each objItem in colItems
'	if (Len(hwList)>0) then hwList=hwList & ","
'	hwList = hwList & "{""display"":{" _
'		& """manufacturer"":""" & objItem.MonitorManufacturer & """," _
'		& """model"":""" & objItem.Caption & """" _
'	& "}}"
'Next

Set colItems = objWMIService.ExecQuery( "Select * from Win32_ComputerSystem", , 48 )
For Each objItem in colItems
	strComputerDomain = split(objItem.Domain,".")(0)
	strComputerName = objItem.Name
Next

monList=GetMonitorInfo
if (Len(monList)>0 ) then
	if (Len(hwList)>0) then hwList=hwList & ","
	hwList=hwList & monList
end if

' Get Windows version 
Set colItems = objWMIService.ExecQuery( "Select * from Win32_OperatingSystem", , 48 )
For Each objItem in colItems
	strOS = objItem.Version&" "&objItem.Caption
	if (Len(productList)>0) then productList=productList & ","
	productList=productList & "{""publisher"":""Microsoft"", ""name"":""" & URL.addslashes(objItem.Caption) & """}" '& vbCrLf
Next
' Get Windows serial
'Set colItems = objWMIService.ExecQuery( "Select * from SoftwareLicensingService", , 48 )
'For Each objItem in colItems
'	productList=productList & ",{""publisher"":""Microsoft"", ""name"":""Windows " & objItem.OA3xOriginalProductKeyDescription & """, ""key"":""" & objItem.OA3xOriginalProductKey & """}" '& vbCrLf
'Next

domainID=getDomainID(strComputerDomain)
if (domainID = -1) then
	Msg "Domain "&strComputerDomain&" not found in inventory database. Please add it manually"
	domainID=""
	'wscript.quit
end if

compID=getCompID(strComputerDomain, strComputerName)
IPv4addrs=getIPv4addrs()
res=updRecord(compID, domainID, strComputerName, strOS, hwList, productList, IPv4addrs)
if (res <> "ok") then
	Msg "ERR: failed send data to database: "&res
elseif (compID>=0) then
	Msg "Got actual compID "&res&"; Database updated"
end if

</script>
</job>