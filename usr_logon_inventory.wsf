<job id="logon_Descr">
<script language="VBScript" src="../libs/lib_core.vbs" ></script>
<script language="VBScript" src="../libs/lib_http.vbs" ></script>
<script language="VBScript" src="../libs/lib_time.vbs" ></script>
<script language="VBScript" src="../config.priv.vbs" ></script>
<script language="javascript" runat="server" src="../libs/lib_url.js" ></script>
<script language="VBScript">
Option explicit
DEBUGMODE=0

'Скрипт фиксирования регистрации пользователя на ПК в БД инвентаризации. 
'Работает не так тупо как раньше - просто добавить запись в БД с текущим временем или попытаться через 5 минут.
'Скрипт определяет время логина пользователя и пытается класть в БД именно набор логин+комп+время
'и кладет только если такого набора там еще нет
'v0.8.2 ! защита от отправки данных со сбитыми часами (не отправляем данные старее 30 дней)
'v0.8.1 * небольшие фиксы. выкинута библиотека lib_aduser, т.к. она выбрасывала ошибку при недоступности контроллера домена (инициируется с запросами к GC/LDAP)
'		все данные мы получаем через WMI запрос, потому либу убрал за ненадобностью
'		НО по факту при отсутствии связи с контроллером домена WMI запрос не может вернуть имя пользователя инициировавшего сессию
'v0.8	! оказалось что при запуске WMI запроса с правами админа, он отдает журнал входов всех пользователей. В связи с этим на каждую запись в журнале дополнительно запрашиваем
'		пользоветеля, который инициировал сессию (чтобы не заявить что все сессии инициированы пользователем-админом, т.к. по факту это не так.)
'		также скидываем привилегии при старте через launchpad
'v0.7 	+ отправляет локальное время ПК для обнаружения сдвига времени ПК относительно времени сервера и для правки времени логона в обратную сторону
'v0.6 	+ отправляет и RDP входы, но указывает в журнале что это именно RDP
'v0.5 	* отправляет время из журнала WMI, а не из момента запуска ПК
'v0.4 	* функцонинал XML парсинга и HTTP REST вынесен в lib_http, URL.encdode/decode -> lib_url
'v0.3 	- вынесено в отдельный скрипт относительно скрипта логона, для запуска по шедулеру в любое время
'v0.2 	- переведено на WSH для подключения библиотек и ведения лога
unPrivelegeMe
const scrName="gp_logonInventory" : const scrVer="0.8.3"
Dim adsinfo, logItems, oShell, strSessionName, vbsTimestamp, strTimestamp, unixTimestamp


'Logon Types
'0 Used only by the System account.
'Interactive (2) Intended for users who are interactively using the machine, such as a user being logged on by a terminal server, remote shell, or similar process.
'Network (3) Intended for high-performance servers to authenticate clear text passwords. LogonUser does not cache credentials for this logon type.
'Batch (4) Intended for batch servers, where processes can be executed on behalf of a user without their direct intervention; or for higher performance servers that process many clear-text authentication attempts at a time, such as mail or web servers. LogonUser does not cache credentials for this logon type.
'Service (5) Indicates a service-type logon. The account provided must have the service privilege enabled.
'Proxy (6) Indicates a proxy-type logon.
'Unlock (7) This logon type is intended for GINA DLLs logging on users who are interactively using the machine. This logon type allows a unique audit record to be generated that shows when the workstation was unlocked.
'NetworkCleartext (8) Preserves the name and password in the authentication packages, allowing the server to make connections to other network servers while impersonating the client. This allows a server to accept clear text credentials from a client, call LogonUser, verify that the user can access the system across the network, and still communicate with other servers.
'NewCredentials (9) Allows the caller to clone its current token and specify new credentials for outbound connections. The new logon session has the same local identify, but uses different credentials for other network connections.
'RemoteInteractive (10) Terminal Services session that is both remote and interactive.
'CachedInteractive (11) Attempt cached credentials without accessing the network.
'CachedRemoteInteractive (12) Same as RemoteInteractive. This is used for internal auditing.
'CachedUnlock (13) Workstation logon.


Class logonEventClass
	dim wmiType,invType, unixTime, strTime, vbsTime, strUserName, strDomainName
	
	Function setWmiTime(wmiTime)
		vbsTime = timeWmiToVbs(wmiTime)
		strTime = timeVbsToTimestamp(vbsTime)
		unixTime = timeVbsToUnix(vbsTime)		
	End function

	Function typeConvert(winType)
		wmiType=winType
		invType=-1
		Select case winType
			case 2
				invType=0
			case 11
				invType=0
			case 10
				invType=1
			case 12
				invType=1
		end select
	End function

	function init(logonEvent)
		init = false
		typeConvert(logonEvent.LogonType)
		if invType<0 then exit function
		
		setWmiTime(objItem.startTime)
		'сценарий когда комп загрузился со сбитыми часами (2001-01-01 00:00:00), зафиксировал в журнале событие входа в 5 минут 1 января
		'а потом часы выставились правильно, и при отправке информации уже не видно сдвига по времени
		'в итоге не отправляем данные о событиях более чем месяц назад
		if (timeGetUnixEpoch-unixTime)>30*24*3600 then exit function
		
		dim colList, objUser
		Set colList = objWMIService.ExecQuery("Associators of {Win32_LogonSession.LogonId=" & logonEvent.LogonId & "} Where AssocClass=Win32_LoggedOnUser Role=Dependent" )
        
		strUserName=""
		strDomainName=""
		if Ubound(colList)>0 then
			For Each objUser in colList
				strUserName = objUser.Name
				strDomainName = objUser.Domain
			Next
		end if
		if strUserName="" or strDomainName="" then exit function

		init = true
	end function

	Function varDump()
		Msg "Logon: [type:" & wmiType & "->" & invType & ", time:" & strTime & ", unix:" & unixTime & " // " & strDomainName & "\" & strUserName &"]"
	End Function

	Function keyString()
		keyString = invType & "-" & unixTime & "-" & strUserName
	End Function



	'ищет запись этого логона в БД возвращает ID созданной/обновленной записи
	function setRecord(byVal comp)
		dim data, res, updRecord
		data="comp_name=" & comp & "&user_login=" & strDomainName & "\" & strUserName & "&time=" & unixTime & "&type=" & invType & "&local_time=" & timeGetUnixEpoch
	
		Msg "Searchin record id of " & data & " ..."
		on error resume next
		res=getXmlData (inventory_apihost & "/web/api/login-journal/search?" & data)
		on error goto 0
		if (getXmlResponseID(res) > -1) then
			updRecord="ok "& res
			Msg "Record already set: " & res & "; Database OK"
		else
	
			Msg "Record not found. Creatin new rec..."
			on error resume next
			res=postXmlData(inventory_apihost & "/web/api/login-journal",data)
			on error goto 0
			if (getXmlResponseID(res) > -1) then
				updRecord="ok " & res
				Msg "Data sent: " & res & "; Database updated"
			else
				Msg "Error sending data ... retrying in next launch"
				Msg data
				Msg res
			end if
		
		end if
	
	end function

	
End Class



dim logFile: logFile = WorkDir & scrName & ".log"
Msg "-" : Msg "Script started: "&scrName&" "&scrVer


dim wshNetwork: Set wshNetwork = CreateObject( "WScript.Network" )
dim strComputerName, strComputerDomain
dim objWMIService: Set objWMIService = GetObject("winmgmts:{impersonationLevel=Impersonate}\\.\root\cimv2")
dim objItems, objItem

Set objItems = objWMIService.ExecQuery("Select * from Win32_ComputerSystem",,48)
For Each objItem in objItems
    strComputerDomain = objItem.Domain
	strComputerName = objItem.Name
Next


'почемуто вот этот вот запрос отдает мне 2 элемента. по собственно времени логона они практически идентичны
'отличаются в микросекундах, но все же отличны. потому данные кладем в словарь с точностью до секунд
Set objItems = objWMIService.ExecQuery ("Select * from Win32_LogonSession")
dim objLogons: set objLogons = CreateObject("Scripting.Dictionary")
dim logonEvent
dim colList, objUser

For Each objItem in objItems
	if DEBUGMODE then
		WScript.Echo "AuthenticationPackage: " & objItem.AuthenticationPackage 
		WScript.Echo "Caption: " & objItem.Caption
		WScript.Echo "Description: " & objItem.Description
		WScript.Echo "InstallDate: " & objItem.InstallDate
		WScript.Echo "LogonId: " & objItem.LogonId
		WScript.Echo "Name: " & objItem.Name
		WScript.Echo "LogonType: " & objItem.LogonType
		WScript.Echo "StartTime: " & objItem.StartTime
		WScript.Echo "Status: " & objItem.Status
	end if

	'Set colList = objWMIService.ExecQuery("Associators of " _
	'	& "{Win32_LogonSession.LogonId=" & objItem.LogonId & "} " _
	'	& "Where AssocClass=Win32_LoggedOnUser Role=Dependent" )
        '
	'	For Each objUser in colList
	'		WScript.Echo "User: " & objUser.Name
	'		WScript.Echo "Domain: " & objUser.Domain
	'		WScript.Echo
	'	Next
	
	set logonEvent = new logonEventClass
	with logonEvent
		if (.init(objItem)) then		
			if not objLogons.exists(.keyString()) then
				objLogons.Add .keyString(), logonEvent
				.varDump
				.setRecord strComputerDomain & "\" & strComputerName
			end if
		end if
	end with
	
Next
Msg "Script complete."

wscript.quit
</script>
</job>