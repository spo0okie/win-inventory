<job id="logon_Descr">
<script language="VBScript" src="../libs/lib_core2.vbs" ></script>
<script language="VBScript" src="../libs/lib_wmi2.vbs" ></script>
<script language="VBScript" src="../libs/lib_time2.vbs" ></script>
<script language="VBScript" src="../libs/lib_http.vbs" ></script>
<script language="VBScript" src="../config.priv.vbs" ></script>
<script language="javascript" runat="server" src="../libs/lib_url.js" ></script>
<script language="VBScript">
Option explicit
DEBUGMODE=0

'Скрипт фиксирования регистрации пользователя на ПК в БД инвентаризации. 
'Работает не так тупо как раньше - просто добавить запись в БД с текущим временем или попытаться через 5 минут.
'Скрипт определяет время логина пользователя и пытается класть в БД именно набор логин+комп+время
'и кладет только если такого набора там еще нет
'v1.4	! code clean
'v1.3   ! Добавлена проверка типа переменной logonEvent передаваемой в logonEventClass
'v1.2   * Обращение к объектам полученным из WMI со сломанным WMI также может вызывать ошибки - добавлены функции getWmiQueryArrayCrit
'v1.1   * Убрано определение hostname/domain через WMI, т.к. в библиотеке CORE они уже загружаются через реестр
'v1.0   ! WMI запросы вынесены в отдельную библиотеку и завернуты в проверку ошибок ВСЕ. Также добавлена оценка времени работы скрипта
'v0.9   * обязательная авторизация. работа с новым API со слепым PUSH данных, без чтения (необходим минимальный набор прав)
'v0.8.5 * WMI запрос завернут в игнор ошибок, чтобы не выбрасывать их пользователю
'v0.8.4 * Добавлена отладка, удален лишний объект WMI
'v0.8.3 * Попытка обработать ошибки доступа
'v0.8.2 ! защита от отправки данных со сбитыми часами (не отправляем данные старее 30 дней)
'v0.8.1 * небольшие фиксы. выкинута библиотека lib_aduser, т.к. она выбрасывала ошибку при недоступности контроллера домена (инициируется с запросами к GC/LDAP)
'		все данные мы получаем через WMI запрос, потому либу убрал за ненадобностью
'		НО по факту при отсутствии связи с контроллером домена WMI запрос не может вернуть имя пользователя инициировавшего сессию
'v0.8	! оказалось что при запуске WMI запроса с правами админа, он отдает журнал входов всех пользователей. В связи с этим на каждую запись в журнале дополнительно запрашиваем
'		пользоветеля, который инициировал сессию (чтобы не заявить что все сессии инициированы пользователем-админом, т.к. по факту это не так.)
'		также скидываем привилегии при старте через launchpad
'v0.7 	+ отправляет локальное время ПК для обнаружения сдвига времени ПК относительно времени сервера и для правки времени логона в обратную сторону
'v0.6 	+ отправляет и RDP входы, но указывает в журнале что это именно RDP
'v0.5 	* отправляет время из журнала WMI, а не из момента запуска ПК
'v0.4 	* функцонинал XML парсинга и HTTP REST вынесен в lib_http, URL.encdode/decode -> lib_url
'v0.3 	- вынесено в отдельный скрипт относительно скрипта логона, для запуска по шедулеру в любое время
'v0.2 	- переведено на WSH для подключения библиотек и ведения лога
'unPrivelegeMe
const scrName="gp_logonInventory" : const scrVer="1.4"
Dim adsinfo, logItems, oShell, strSessionName, vbsTimestamp, strTimestamp, unixTimestamp
dim logFile : logFile = WorkDir & scrName & ".log"

'Logon Types
'0 Used only by the System account.
'Interactive (2) Intended for users who are interactively using the machine, such as a user being logged on by a terminal server, remote shell, or similar process.
'Network (3) Intended for high-performance servers to authenticate clear text passwords. LogonUser does not cache credentials for this logon type.
'Batch (4) Intended for batch servers, where processes can be executed on behalf of a user without their direct intervention; or for higher performance servers that process many clear-text authentication attempts at a time, such as mail or web servers. LogonUser does not cache credentials for this logon type.
'Service (5) Indicates a service-type logon. The account provided must have the service privilege enabled.
'Proxy (6) Indicates a proxy-type logon.
'Unlock (7) This logon type is intended for GINA DLLs logging on users who are interactively using the machine. This logon type allows a unique audit record to be generated that shows when the workstation was unlocked.
'NetworkCleartext (8) Preserves the name and password in the authentication packages, allowing the server to make connections to other network servers while impersonating the client. This allows a server to accept clear text credentials from a client, call LogonUser, verify that the user can access the system across the network, and still communicate with other servers.
'NewCredentials (9) Allows the caller to clone its current token and specify new credentials for outbound connections. The new logon session has the same local identify, but uses different credentials for other network connections.
'RemoteInteractive (10) Terminal Services session that is both remote and interactive.
'CachedInteractive (11) Attempt cached credentials without accessing the network.
'CachedRemoteInteractive (12) Same as RemoteInteractive. This is used for internal auditing.
'CachedUnlock (13) Workstation logon.


Class logonEventClass
	dim wmiType, invType, unixTime, strTime, vbsTime, strUserName, strDomainName
	
	Function setWmiTime(wmiTime)
		vbsTime = timeWmiToVbs(wmiTime)
		strTime = timeVbsToTimestamp(vbsTime)
		unixTime = timeVbsToUnix(vbsTime)		
	End function

	Function typeConvert(winType)
		wmiType=winType
		invType=-1
		Select case winType
			case 2	'интерактивный вход в консоль
				invType=0
			case 11	'интерактивный вход в консоль используя кэшированные учетные данные
				invType=0
			case 10 'RDP
				invType=1
			case 12	'RDP используя кэшированные учетные данные
				invType=1
		end select
	End function

	function init(logonEvent)
		init = false

		typeConvert(logonEvent.LogonType)
		if invType<0 then 
			debugMsg "Ignoring event " & logonEvent.LogonId & " with type " & logonEvent.LogonType
			exit function
		end if
		
		setWmiTime(logonEvent.startTime)
		'сценарий когда комп загрузился со сбитыми часами (2001-01-01 00:00:00), зафиксировал в журнале событие входа в 5 минут 1 января
		'а потом часы выставились правильно, и при отправке информации уже не видно сдвига по времени
		'в итоге не отправляем данные о событиях более чем месяц назад
		if (timeGetUnixEpoch-unixTime)>100*24*3600 then 
			debugMsg "Ignoring event " & logonEvent.LogonId & " with tooo old date " & strTime
			exit function
		end if
		
		strUserName=""
		strDomainName=""
		dim colList, objUser
		Set colList = getWmiQueryCrit("Associators of {Win32_LogonSession.LogonId=" & logonEvent.LogonId & "} Where AssocClass=Win32_LoggedOnUser" )       
		on error resume next
		For Each objUser in colList
			strUserName = objUser.Name
			strDomainName = objUser.Domain
		Next
		on error goto 0
		if strUserName="" or strDomainName="" then 
			debugMsg "Can't find event " & logonEvent.LogonId & " username "
			exit function
		end if

		init = true
	end function

	Function varDump()
		Msg "Logon: [type:" & wmiType & "->" & invType & ", time:" & strTime & ", unix:" & unixTime & " // " & strDomainName & "\" & strUserName &"]"
	End Function

	Function keyString()
		keyString = invType & "-" & unixTime & "-" & strUserName
	End Function



	'ищет запись этого логона в БД возвращает ID созданной/обновленной записи
	function setRecord(byVal comp)
		dim data, res, updRecord
		data="comp_name=" & comp & "&user_login=" & strDomainName & "\" & strUserName & "&time=" & unixTime & "&type=" & invType & "&local_time=" & timeGetUnixEpoch
	
		on error resume next
		res=postAuthXmlData(inventory_apihost & "/web/api/login-journal/push",data,inventory_user,inventory_password)
		on error goto 0
		if (getXmlResponseID(res) > -1) then
			updRecord="ok " & res
			Msg "Data sent: " & res & "; Database updated"
		else
			Msg "Error sending data ... retrying in next launch"
			Msg data
			Msg res
		end if	
	end function

	
End Class



dim logFile: logFile = WorkDir & scrName & ".log"
Msg "-" : Msg "Script started: "&scrName&" "&scrVer

'почемуто вот этот вот запрос отдает мне 2 элемента. по собственно времени логона они практически идентичны
'отличаются в микросекундах, но все же отличны. потому данные кладем в словарь с точностью до секунд
dim objItems, objItem
objItems = getWmiQueryArrayCrit ("Select * from Win32_LogonSession")
dim objLogons: set objLogons = CreateObject("Scripting.Dictionary")
dim logonEvent
dim colList, objUser, objType
For Each objItem in objItems
	objType = getVariableType(objItem)
	If objType = "SWbemObjectEx" Then
		if DEBUGMODE then
			msg "AuthenticationPackage: " & objItem.AuthenticationPackage 
			msg "Caption: " & objItem.Caption
			msg "Description: " & objItem.Description
			msg "InstallDate: " & objItem.InstallDate
			msg "LogonId: " & objItem.LogonId
			msg "Name: " & objItem.Name
			msg "LogonType: " & objItem.LogonType
			msg "StartTime: " & objItem.StartTime
			msg "Status: " & objItem.Status
		end if
		set logonEvent = new logonEventClass
		with logonEvent
			if (.init(objItem)) then		
				if not objLogons.exists(.keyString()) then
					objLogons.Add .keyString(), logonEvent
					.varDump
					.setRecord ComputerName & "." & ComputerDomain
				end if
			end if
		end with
	else
		debugMsg "Ignoring non-SWbemObjectEx event variable: " & objType
	end if	
Next
Done

</script>
</job>
